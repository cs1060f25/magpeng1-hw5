#!/usr/bin/env python3
"""
Vulnerability Scanner for CS1060 HW5
Scans localhost for open ports and tests for weak HTTP/SSH credentials.

Code generated with assistance from Cascade (Windsurf) AI.
"""

import nmap
import requests
import paramiko
import socket
import argparse
import sys
from requests.auth import HTTPBasicAuth
from urllib.parse import quote

# Credentials dictionary as specified in assignment
credentials = {
    'admin': 'admin',
    'root': 'abc123',
    'skroob': '12345'
}

def scan_ports(verbose=False):
    """Scan localhost for open TCP ports below 9000 using nmap"""
    if verbose:
        print("Scanning localhost for open ports...", file=sys.stderr)
    
    try:
        nm = nmap.PortScanner()
        # Scan ports 1-8999 on localhost
        nm.scan('127.0.0.1', '1-8999', '-sT')
        open_ports = []
        
        if '127.0.0.1' in nm.all_hosts():
            for port in nm['127.0.0.1']['tcp']:
                if nm['127.0.0.1']['tcp'][port]['state'] == 'open':
                    open_ports.append(port)
                    if verbose:
                        print(f"Port {port} is open", file=sys.stderr)
        
        if verbose:
            print(f"Found open ports: {open_ports}", file=sys.stderr)
        
        return open_ports
    except Exception as e:
        if verbose:
            print(f"nmap scan error: {e}", file=sys.stderr)
            print("Falling back to socket scanning...", file=sys.stderr)
        
        # Fallback to socket scanning if nmap fails
        return scan_ports_fallback(verbose)

def scan_ports_fallback(verbose=False):
    """Fallback socket-based port scanning if nmap is not available"""
    open_ports = []
    
    # Common ports to check (focusing on likely test ports)
    common_ports = [22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 1433, 1521, 2222, 3306, 3389, 5432, 8080, 8081, 8443]
    
    # Add some additional ports in common ranges
    for port_range in [(1000, 1100), (2000, 2300), (3000, 3100), (8000, 8200)]:
        common_ports.extend(range(port_range[0], port_range[1]))
    
    # Remove duplicates and filter ports >= 9000
    ports_to_scan = sorted(list(set([p for p in common_ports if p < 9000])))
    
    for port in ports_to_scan:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)  # 1 second timeout
            result = sock.connect_ex(('127.0.0.1', port))
            sock.close()
            
            if result == 0:  # Port is open
                open_ports.append(port)
                if verbose:
                    print(f"Port {port} is open", file=sys.stderr)
        except Exception as e:
            if verbose:
                print(f"Error scanning port {port}: {e}", file=sys.stderr)
            continue
    
    return open_ports

def test_http_auth(port, verbose=False):
    """Test HTTP basic authentication on given port"""
    if verbose:
        print(f"Testing HTTP auth on port {port}...", file=sys.stderr)
    
    for username, password in credentials.items():
        try:
            # Try HTTP connection with basic auth
            url = f"http://127.0.0.1:{port}/"
            response = requests.get(url, auth=HTTPBasicAuth(username, password), timeout=5)
            
            if response.status_code == 200:
                server_output = response.text.strip()
                # Format output according to RFC 3986: protocol://user:pass@host:port
                print(f"http://{quote(username)}:{quote(password)}@127.0.0.1:{port} {server_output}")
                return True
                
        except Exception as e:
            if verbose:
                print(f"HTTP test error for {username}:{password} on port {port}: {e}", file=sys.stderr)
            continue
    
    return False

def test_ssh_auth(port, verbose=False):
    """Test SSH password authentication on given port"""
    if verbose:
        print(f"Testing SSH auth on port {port}...", file=sys.stderr)
    
    for username, password in credentials.items():
        ssh_client = None
        try:
            # Suppress paramiko logging to avoid error messages
            import logging
            logging.getLogger("paramiko").setLevel(logging.CRITICAL)
            
            ssh_client = paramiko.SSHClient()
            ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            # Connect with password authentication
            ssh_client.connect(
                hostname='127.0.0.1',
                port=port,
                username=username,
                password=password,
                timeout=10,
                allow_agent=False,
                look_for_keys=False
            )
            
            # Try to open a channel and read server output
            transport = ssh_client.get_transport()
            if transport:
                channel = transport.open_session()
                if channel:
                    # Read any data the server sends
                    channel.settimeout(5)
                    try:
                        data = channel.recv(1024)
                        server_output = data.decode('utf-8').strip()
                    except:
                        server_output = "success"  # Default if no data received
                    
                    # Format output according to RFC 3986: protocol://user:pass@host:port
                    print(f"ssh://{quote(username)}:{quote(password)}@127.0.0.1:{port} {server_output}")
                    channel.close()
                    return True
            
        except Exception as e:
            if verbose:
                print(f"SSH test error for {username}:{password} on port {port}: {e}", file=sys.stderr)
            continue
        finally:
            if ssh_client:
                try:
                    ssh_client.close()
                except:
                    pass
    
    return False

def main():
    """Main scanner function"""
    # Suppress paramiko and urllib3 warnings
    import logging
    import warnings
    logging.getLogger("paramiko").setLevel(logging.CRITICAL)
    warnings.filterwarnings("ignore")
    
    parser = argparse.ArgumentParser(description='Vulnerability scanner for weak credentials')
    parser.add_argument('-v', '--verbose', action='store_true', 
                       help='Print verbose messages to stderr')
    args = parser.parse_args()
    
    # Scan for open ports
    open_ports = scan_ports(args.verbose)
    
    if not open_ports:
        if args.verbose:
            print("No open ports found", file=sys.stderr)
        return
    
    # Test each open port for vulnerabilities
    for port in open_ports:
        if args.verbose:
            print(f"Testing port {port}...", file=sys.stderr)
        
        # Test HTTP basic auth
        test_http_auth(port, args.verbose)
        
        # Test SSH password auth
        test_ssh_auth(port, args.verbose)

if __name__ == '__main__':
    main()
